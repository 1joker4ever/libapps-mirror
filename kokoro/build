#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright 2019 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Do all the things!"""

from __future__ import print_function

import argparse
import glob
import logging
import os
import shutil
import sys

import kokoro
import libdot


# Where kokoro expects files to end up.  Anything put in this dir will be
# uploaded & archived, while everything else will be discarded.
ARTIFACTS_DIR = os.path.join(kokoro.LIBAPPS_DIR, 'artifacts')

# Where we drop all our comment files for passing back to gerrit.
# Kokoro can handle more than one file, but they must all be named the same
# "gerrit_comments.json".  So we have to namespace the files under dirs.
# We'll use a convention like gerrit_comments/$PKG/$TOOL/.
GERRIT_COMMENTS_NAME = 'gerrit_comments.json'
GERRIT_COMMENTS_DIR = os.path.join(ARTIFACTS_DIR, 'gerrit_comments')


def is_presubmit():
    """Whether we're testing a pending CL."""
    # This env var is passed down by kokoro.
    return bool(os.environ.get('KOKORO_GERRIT_REVISION'))


def build_archive():
    """Move compiled files to artifacts output tree."""
    # Unpack the nassh extensions so they can be packaged & signed.
    nassh_dir = os.path.join(kokoro.LIBAPPS_DIR, 'nassh')
    zip_dir = os.path.join(nassh_dir, 'dist', 'zip')
    for archive in glob.glob(os.path.join(zip_dir, 'SecureShell*.zip')):
        # The archives look like:
        #   SecureShellApp-0.20.zip
        #   SecureShellApp-dev-0.20.7220.2157.zip
        # We want to output dirs like:
        #   SecureShellApp/
        #   SecureShellApp-dev/
        output = os.path.basename(archive).rsplit('-', 1)[0]
        libdot.run(['unzip', archive, '-d',
                    os.path.join(ARTIFACTS_DIR, output)])

    # Copy over the nacl ssh build with debug info.
    ssh_client_dir = os.path.join(kokoro.LIBAPPS_DIR, 'ssh_client')
    os.rename(os.path.join(ssh_client_dir, 'output', 'release.tar.xz'),
              os.path.join(ARTIFACTS_DIR, 'ssh_client-release.tar.xz'))


def build():
    """Build the various components."""
    # Build the ssh client code.
    ssh_client_dir = os.path.join(kokoro.LIBAPPS_DIR, 'ssh_client')
    libdot.run(['./build.sh'], cwd=ssh_client_dir)
    # Copy output files.
    libdot.run(['cp', '-r', './ssh_client/output/plugin/', './nassh/'],
               cwd=kokoro.LIBAPPS_DIR)

    # Build the nassh program.
    nassh_dir = os.path.join(kokoro.LIBAPPS_DIR, 'nassh')
    zip_dir = os.path.join(nassh_dir, 'dist', 'zip')
    shutil.rmtree(zip_dir, ignore_errors=True)
    libdot.run(['./bin/mkzip.sh', '--nouse_manifest_platforms'], cwd=nassh_dir)

    # Promote extension and app dev zips.
    for path in glob.glob(os.path.join(zip_dir, '*V2*.zip')):
        libdot.unlink(path)
    for path in glob.glob(os.path.join(zip_dir, 'SecureShell*.zip')):
        libdot.run(['./bin/promote.sh', path], cwd=nassh_dir)

    build_archive()


def _run_linter(cmd, cwd):
    """Run the linter taking into account presubmit bot state."""
    result = libdot.run(cmd, check=False, cwd=cwd)
    if result.returncode:
        msg = '%s linter exited %i' % (cmd[0], result.returncode)
        if is_presubmit():
            logging.error(msg)
            return False
        else:
            logging.warning('%s; ignoring for release builds', msg)
    return True


def test_jslint():
    """Lint all our JS files."""
    ret = True
    for pkg in ('libdot', 'hterm', 'nassh', 'terminal'):
        pkg_dir = os.path.join(kokoro.LIBAPPS_DIR, pkg)
        cmd = [
            './bin/lint',
            '--gerrit-comments-file',
            os.path.join(GERRIT_COMMENTS_DIR, pkg, 'eslint',
                         GERRIT_COMMENTS_NAME),
        ]
        ret &= _run_linter(cmd, pkg_dir)
    return ret


def test_unittests():
    """Run all the unittests."""
    ret = True
    for pkg in ('libdot', 'hterm', 'nassh', 'terminal'):
        pkg_dir = os.path.join(kokoro.LIBAPPS_DIR, pkg)
        if os.path.exists(os.path.join(pkg_dir, 'package.json')):
            cmd = ['npm', 'test', '--', '--no-sandbox']
        else:
            cmd = ['./bin/load_tests', '--no-sandbox']
        result = libdot.run(cmd, check=False, cwd=pkg_dir)
        if result.returncode:
            logging.error('%s test suite exited %i', pkg, result.returncode)
            ret = False
    return ret


def test():
    """Test the various components."""
    success = True

    # Run all the tests before aborting.
    success &= test_jslint()
    success &= test_unittests()

    if not success:
        sys.exit(1)


def clean():
    """Clean up various compiled objects.

    When kokoro is done (pass or fail), it archives the tree via rsync.
    Remove all the compiled objects since we don't need them.
    """
    ssh_client_dir = os.path.join(kokoro.LIBAPPS_DIR, 'ssh_client')
    shutil.rmtree(os.path.join(ssh_client_dir, 'output'), ignore_errors=True)

    shutil.rmtree(libdot.node.NODE_MODULES_DIR, ignore_errors=True)


def setup():
    """Set up the overall state before we build/test."""
    # Log some system state so we can see current CI/container state.
    libdot.run(['uname', '-a'])
    libdot.run(['cat', '/etc/os-release'], check=False)

    # Initialize the artifacts output.
    logging.info('Setting up artifacts output %s', ARTIFACTS_DIR)
    shutil.rmtree(ARTIFACTS_DIR, ignore_errors=True)
    os.makedirs(ARTIFACTS_DIR)

    # Create the dropbox for gerrit comments.
    os.makedirs(GERRIT_COMMENTS_DIR)
    # Always create a stub comments file.  The kokoro docs don't say this is
    # required, but other users report it doesn't post updates back to Gerrit
    # unless it exists, and we're seeing that same behavior.
    # http://g/kokoro-users/coBW2tNu46g/W8PozUUpAQAJ
    stub = os.path.join(GERRIT_COMMENTS_DIR, GERRIT_COMMENTS_NAME)
    with open(stub, 'w') as fp:
        fp.write('[]')


def get_parser():
    """Get a command line parser."""
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('-d', '--debug', action='store_true',
                        help='Run with debug output.')
    parser.add_argument('--skip-clean', dest='clean',
                        action='store_false', default=True,
                        help='Clean up compiled object dirs.')
    return parser


def main(argv):
    """The main func!"""
    parser = get_parser()
    opts = parser.parse_args(argv)
    libdot.setup_logging(debug=opts.debug)
    libdot.node_and_npm_setup()

    setup()
    try:
        build()
        test()
    finally:
        if opts.clean:
            clean()

if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
